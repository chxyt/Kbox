This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License, Version 2.0 and
only version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache 2.0 for more details.



diff -uNr frameworks_old/build/phone-xhdpi-2048-dalvik-heap.mk frameworks_new/build/phone-xhdpi-2048-dalvik-heap.mk
--- frameworks_old/build/phone-xhdpi-2048-dalvik-heap.mk	2020-10-29 14:46:53.845273772 +0800
+++ frameworks_new/build/phone-xhdpi-2048-dalvik-heap.mk	2020-10-29 15:07:42.001229700 +0800
@@ -18,8 +18,8 @@
 # 192m of RAM gives enough space for 5 8 megapixel camera bitmaps in RAM.

 PRODUCT_PROPERTY_OVERRIDES += \
-    dalvik.vm.heapstartsize=8m \
-    dalvik.vm.heapgrowthlimit=192m \
+    dalvik.vm.heapstartsize=16m \
+    dalvik.vm.heapgrowthlimit=384m \
     dalvik.vm.heapsize=512m \
     dalvik.vm.heaptargetutilization=0.75 \
     dalvik.vm.heapminfree=512k \
diff --git a/cmds/installd/InstalldNativeService.cpp b/cmds/installd/InstalldNativeService.cpp
index 860a68b27..80c15d746 100644
--- a/cmds/installd/InstalldNativeService.cpp
+++ b/cmds/installd/InstalldNativeService.cpp
@@ -295,47 +295,11 @@
  */
 static int restorecon_app_data_lazy(const std::string& path, const std::string& seInfo, uid_t uid,
         bool existing) {
-    int res = 0;
-    char* before = nullptr;
-    char* after = nullptr;
-
-    // Note that SELINUX_ANDROID_RESTORECON_DATADATA flag is set by
-    // libselinux. Not needed here.
-
-    if (lgetfilecon(path.c_str(), &before) < 0) {
-        PLOG(ERROR) << "Failed before getfilecon for " << path;
-        goto fail;
-    }
-    if (selinux_android_restorecon_pkgdir(path.c_str(), seInfo.c_str(), uid, 0) < 0) {
-        PLOG(ERROR) << "Failed top-level restorecon for " << path;
-        goto fail;
-    }
-    if (lgetfilecon(path.c_str(), &after) < 0) {
-        PLOG(ERROR) << "Failed after getfilecon for " << path;
-        goto fail;
-    }
-
-    // If the initial top-level restorecon above changed the label, then go
-    // back and restorecon everything recursively
-    if (strcmp(before, after)) {
-        if (existing) {
-            LOG(DEBUG) << "Detected label change from " << before << " to " << after << " at "
-                    << path << "; running recursive restorecon";
-        }
-        if (selinux_android_restorecon_pkgdir(path.c_str(), seInfo.c_str(), uid,
-                SELINUX_ANDROID_RESTORECON_RECURSE) < 0) {
-            PLOG(ERROR) << "Failed recursive restorecon for " << path;
-            goto fail;
-        }
-    }
-
-    goto done;
-fail:
-    res = -1;
-done:
-    free(before);
-    free(after);
-    return res;
+    (void) path;
+    (void) seInfo;
+    (void) uid;
+    (void) existing;
+    return 0;
 }

 static int restorecon_app_data_lazy(const std::string& parent, const char* name,
diff --git a/opengl/libs/EGL/Loader.cpp b/opengl/libs/EGL/Loader.cpp
index 91a34558a..4ce3f052d 100644
--- a/opengl/libs/EGL/Loader.cpp
+++ b/opengl/libs/EGL/Loader.cpp
@@ -73,40 +73,6 @@
     return loader;
 }

-/* This function is called to check whether we run inside the emulator,
- * and if this is the case whether GLES GPU emulation is supported.
- *
- * Returned values are:
- *  -1   -> not running inside the emulator
- *   0   -> running inside the emulator, but GPU emulation not supported
- *   1   -> running inside the emulator, GPU emulation is supported
- *          through the "emulation" host-side OpenGL ES implementation.
- *   2   -> running inside the emulator, GPU emulation is supported
- *          through a guest-side vendor driver's OpenGL ES implementation.
- */
-static int
-checkGlesEmulationStatus(void)
-{
-    /* We're going to check for the following kernel parameters:
-     *
-     *    qemu=1                      -> tells us that we run inside the emulator
-     *    android.qemu.gles=<number>  -> tells us the GLES GPU emulation status
-     *
-     * Note that we will return <number> if we find it. This let us support
-     * more additionnal emulation modes in the future.
-     */
-    char  prop[PROPERTY_VALUE_MAX];
-    int   result = -1;
-
-    /* First, check for qemu=1 */
-    property_get("ro.kernel.qemu",prop,"0");
-    if (atoi(prop) != 1)
-        return -1;
-
-    /* We are in the emulator, get GPU status value */
-    property_get("qemu.gles",prop,"0");
-    return atoi(prop);
-}

 static void* do_dlopen(const char* path, int mode) {
     ATRACE_CALL();
@@ -323,13 +289,18 @@
     public:
         static std::string find(const char* kind) {
             std::string result;
-            int emulationStatus = checkGlesEmulationStatus();
-            switch (emulationStatus) {
+            // int emulationStatus = checkGlesEmulationStatus();
+            // video stream use 0(default)
+            // instruction stream use 1
+            char prop[PROPERTY_VALUE_MAX];
+            property_get("ro.kernel.kbox", prop, "0");
+            int emulationStatus = std::stoi(prop);
+           switch (emulationStatus) {
                 case 0:
 #if defined(__LP64__)
-                    result = "/vendor/lib64/egl/libGLES_android.so";
+                    result = "/vendor/lib64/egl/libGLES_mesa.so";
 #else
-                    result = "/vendor/lib/egl/libGLES_android.so";
+                    result = "/vendor/lib/egl/libGLES_mesa.so";
 #endif
                     return result;
                 case 1:
diff -uNr frameworks_old/opengl/libs/EGL/eglApi.cpp frameworks_new/opengl/libs/EGL/eglApi.cpp
--- frameworks_old/opengl/libs/EGL/eglApi.cpp	2020-10-29 14:46:53.897273771 +0800
+++ frameworks_new/opengl/libs/EGL/eglApi.cpp	2020-10-29 15:07:42.037229699 +0800
@@ -1369,6 +1369,37 @@ EGLBoolean eglSwapBuffersWithDamageKHR(E
     ATRACE_CALL();
     clearError();

+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.egl.call_freq", value, "false");
+    if (!strcmp(value,"true")) {
+        static struct timeval t_start_eglSwapBuffersWithDamageKHR,t_end_eglSwapBuffersWithDamageKHR;
+        static long long last_t_eglSwapBuffersWithDamageKHR = 0;
+        static int frame_cnt_eglSwapBuffersWithDamageKHR = 0;
+        long long current_t = 0;
+        long long diff_t = 0;
+        double frequent = 0;
+        struct timeval t_time;
+        frame_cnt_eglSwapBuffersWithDamageKHR++;
+        if(last_t_eglSwapBuffersWithDamageKHR == 0)
+        {
+                gettimeofday (&t_time , NULL);
+                 last_t_eglSwapBuffersWithDamageKHR = t_time.tv_sec*1000000 + t_time.tv_usec;
+             }
+             else
+             {
+                 if(frame_cnt_eglSwapBuffersWithDamageKHR == 100)
+                 {
+                     gettimeofday (&t_time , NULL);
+                     current_t = t_time.tv_sec*1000000 + t_time.tv_usec;
+                     diff_t = current_t - last_t_eglSwapBuffersWithDamageKHR;
+                     frequent = (100*1000000.0) / diff_t;
+                     ALOGD("%s called_frequent diff_t=%lld %.1f\n", "eglSwapBuffersWithDamageKHR", diff_t, frequent);
+                     last_t_eglSwapBuffersWithDamageKHR = current_t;
+                     frame_cnt_eglSwapBuffersWithDamageKHR = 0;
+                 }
+             }
+        }
+
     const egl_display_ptr dp = validate_display(dpy);
     if (!dp) return EGL_FALSE;

diff -Nurp a/libs/dumputils/dump_utils.cpp b/libs/dumputils/dump_utils.cpp
--- a/libs/dumputils/dump_utils.cpp	2020-12-18 17:22:21.362711519 +0800
+++ b/libs/dumputils/dump_utils.cpp	2020-12-18 17:23:13.826711519 +0800
@@ -31,7 +31,7 @@ static const char* native_processes_to_d
         "/system/bin/mediaextractor", // media.extractor
         "/system/bin/mediametrics", // media.metrics
         "/system/bin/mediaserver",
-        "/system/bin/sdcard",
+        //"/system/bin/sdcard", // dump will make sdcard crash
         "/system/bin/statsd",
         "/system/bin/surfaceflinger",
         "/system/bin/vehicle_network_service",
diff -Nurp Surface_old/libs/gui/Surface.cpp Surface_new/libs/gui/Surface.cpp
--- Surface_old/libs/gui/Surface.cpp	2021-02-19 17:35:57.087888291 +0800
+++ Surface_new/libs/gui/Surface.cpp	2021-02-19 17:34:43.991888291 +0800
@@ -27,6 +27,7 @@
 #include <utils/Log.h>
 #include <utils/Trace.h>
 #include <utils/NativeHandle.h>
+#include <cutils/properties.h>

 #include <ui/DisplayStatInfo.h>
 #include <ui/Fence.h>
@@ -1735,10 +1736,26 @@ status_t Surface::lock(
             *inOutDirtyBounds = newDirtyRegion.getBounds();
         }

+        // hwmock if property ro.sys.vmi.cloudphone is set ,then set inUsage
+        static uint32_t inUsage = GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN;
+        static bool needReadProp = true;
+        if (needReadProp) {
+            char value[PROPERTY_VALUE_MAX] = {0};
+            property_get("ro.sys.vmi.cloudphone", value, "unknow");
+            if (strcmp(value, "instruction") == 0) {
+                inUsage ^= GRALLOC_USAGE_SW_READ_OFTEN;
+            }
+            needReadProp = false;
+            ALOGV("running mode is %s", value);
+        }
+
+
         void* vaddr;
-        status_t res = backBuffer->lockAsync(
-                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
-                newDirtyRegion.bounds(), &vaddr, fenceFd);
+        // status_t res = backBuffer->lockAsync(
+        //         GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
+        //         newDirtyRegion.bounds(), &vaddr, fenceFd);
+        // hwmock if property ro.sys.vmi.cloudphone is set ,then set inUsage
+        status_t res = backBuffer->lockAsync(inUsage, newDirtyRegion.bounds(), &vaddr, fenceFd);

         ALOGW_IF(res, "failed locking buffer (handle = %p)",
                 backBuffer->handle);
diff -Nurp a/include/gui/CpuConsumer.h b/include/gui/CpuConsumer.h
--- a/include/gui/CpuConsumer.h	2021-04-21 09:52:36.360403340 +0800
+++ b/include/gui/CpuConsumer.h	2021-04-21 20:17:07.698272166 +0800
@@ -105,6 +105,9 @@ class CpuConsumer : public ConsumerBase
     // by calling unlockBuffer before more buffers can be acquired.
     status_t lockNextBuffer(LockedBuffer *nativeBuffer);
 
+    // For EncTurbo
+    status_t lockNextBufferEncTurbo(LockedBuffer *nativeBuffer);
+
     // Returns a locked buffer to the queue, allowing it to be reused. Since
     // only a fixed number of buffers may be locked at a time, old buffers must
     // be released by calling unlockBuffer to ensure new buffers can be acquired by
diff -Nurp a/libs/gui/CpuConsumer.cpp b/libs/gui/CpuConsumer.cpp
--- a/libs/gui/CpuConsumer.cpp	2021-04-21 09:52:36.380403341 +0800
+++ b/libs/gui/CpuConsumer.cpp	2021-04-21 21:16:35.069479569 +0800
@@ -22,6 +22,8 @@
 
 #include <gui/BufferItem.h>
 #include <utils/Log.h>
+#include <cutils/properties.h>
+#include <string>
 
 #define CC_LOGV(x, ...) ALOGV("[%s] " x, mName.string(), ##__VA_ARGS__)
 //#define CC_LOGD(x, ...) ALOGD("[%s] " x, mName.string(), ##__VA_ARGS__)
@@ -195,6 +197,136 @@ status_t CpuConsumer::lockNextBuffer(Loc
     return OK;
 }
 
+// For EncTurbo
+status_t CpuConsumer::lockNextBufferEncTurbo(LockedBuffer *nativeBuffer) {
+    status_t err;
+
+    if (!nativeBuffer) {
+         return BAD_VALUE;
+    }
+    if (mCurrentLockedBuffers == mMaxLockedBuffers) {
+        CC_LOGW("Max buffers have been locked (%zd), cannot lock anymore.",
+                mMaxLockedBuffers);
+        return NOT_ENOUGH_DATA;
+    }
+
+    BufferItem b;
+
+    Mutex::Autolock _l(mMutex);
+
+    err = acquireBufferLocked(&b, 0);
+    if (err != OK) {
+        if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
+            return BAD_VALUE;
+        } else {
+            CC_LOGE("Error acquiring buffer: %s (%d)", strerror(err), err);
+            return err;
+        }
+    }
+
+    int slot = b.mSlot;
+
+    void *bufferPointer = NULL;
+    android_ycbcr ycbcr = android_ycbcr();
+
+    PixelFormat format = mSlots[slot].mGraphicBuffer->getPixelFormat();
+    PixelFormat flexFormat = format;
+    if (isPossiblyYUV(format)) {
+        if (b.mFence.get()) {
+            err = mSlots[slot].mGraphicBuffer->lockAsyncYCbCr(
+                GraphicBuffer::USAGE_SW_READ_OFTEN,
+                b.mCrop,
+                &ycbcr,
+                b.mFence->dup());
+        } else {
+            err = mSlots[slot].mGraphicBuffer->lockYCbCr(
+                GraphicBuffer::USAGE_SW_READ_OFTEN,
+                b.mCrop,
+                &ycbcr);
+        }
+        if (err == OK) {
+            bufferPointer = ycbcr.y;
+            flexFormat = HAL_PIXEL_FORMAT_YCbCr_420_888;
+            if (format != HAL_PIXEL_FORMAT_YCbCr_420_888) {
+                CC_LOGV("locking buffer of format %#x as flex YUV", format);
+            }
+        } else if (format == HAL_PIXEL_FORMAT_YCbCr_420_888) {
+            CC_LOGE("Unable to lock YCbCr buffer for CPU reading: %s (%d)",
+                    strerror(-err), err);
+            return err;
+        }
+    }
+
+    if (bufferPointer == NULL) { // not flexible YUV
+        if (b.mFence.get()) {
+            char propBuf[PROPERTY_VALUE_MAX];
+            property_get("vmi.videostream.engine", propBuf, NULL);
+            if (std::string(propBuf) == "true") {
+                err = mSlots[slot].mGraphicBuffer->lockAsyncEncTurbo(
+                GraphicBuffer::USAGE_SW_READ_OFTEN,
+                b.mCrop,
+                &bufferPointer,
+                b.mFence->dup());                
+            } else {
+                err = mSlots[slot].mGraphicBuffer->lockAsync(
+                GraphicBuffer::USAGE_SW_READ_OFTEN,
+                b.mCrop,
+                &bufferPointer,
+                b.mFence->dup());
+            }
+        } else {
+            err = mSlots[slot].mGraphicBuffer->lock(
+                GraphicBuffer::USAGE_SW_READ_OFTEN,
+                b.mCrop,
+                &bufferPointer);
+        }
+        if (err != OK) {
+            CC_LOGE("Unable to lock buffer for CPU reading: %s (%d)",
+                    strerror(-err), err);
+            return err;
+        }
+    }
+
+    size_t lockedIdx = 0;
+    for (; lockedIdx < static_cast<size_t>(mMaxLockedBuffers); lockedIdx++) {
+        if (mAcquiredBuffers[lockedIdx].mSlot ==
+                BufferQueue::INVALID_BUFFER_SLOT) {
+            break;
+        }
+    }
+    assert(lockedIdx < mMaxLockedBuffers);
+
+    AcquiredBuffer &ab = mAcquiredBuffers.editItemAt(lockedIdx);
+    ab.mSlot = slot;
+    ab.mLockedBufferId = reinterpret_cast<uintptr_t>(bufferPointer);
+    ab.mGraphicBuffer = mSlots[slot].mGraphicBuffer;
+
+    nativeBuffer->data   =
+            reinterpret_cast<uint8_t*>(bufferPointer);
+    nativeBuffer->width  = mSlots[slot].mGraphicBuffer->getWidth();
+    nativeBuffer->height = mSlots[slot].mGraphicBuffer->getHeight();
+    nativeBuffer->format = format;
+    nativeBuffer->flexFormat = flexFormat;
+    nativeBuffer->stride = (ycbcr.y != NULL) ?
+            static_cast<uint32_t>(ycbcr.ystride) :
+            mSlots[slot].mGraphicBuffer->getStride();
+
+    nativeBuffer->crop        = b.mCrop;
+    nativeBuffer->transform   = b.mTransform;
+    nativeBuffer->scalingMode = b.mScalingMode;
+    nativeBuffer->timestamp   = b.mTimestamp;
+    nativeBuffer->dataSpace   = b.mDataSpace;
+    nativeBuffer->frameNumber = b.mFrameNumber;
+
+    nativeBuffer->dataCb       = reinterpret_cast<uint8_t*>(ycbcr.cb);
+    nativeBuffer->dataCr       = reinterpret_cast<uint8_t*>(ycbcr.cr);
+    nativeBuffer->chromaStride = static_cast<uint32_t>(ycbcr.cstride);
+    nativeBuffer->chromaStep   = static_cast<uint32_t>(ycbcr.chroma_step);
+
+    mCurrentLockedBuffers++;
+    return OK;
+}
+
 status_t CpuConsumer::unlockBuffer(const LockedBuffer &nativeBuffer) {
     Mutex::Autolock _l(mMutex);
 
diff -Nurp a/libs/ui/Gralloc2.cpp b/libs/ui/Gralloc2.cpp
--- a/libs/ui/Gralloc2.cpp	2021-04-21 09:52:36.592403349 +0800
+++ b/libs/ui/Gralloc2.cpp	2021-04-21 20:24:19.538287949 +0800
@@ -240,6 +240,41 @@ Error Mapper::lock(buffer_handle_t buffe
     return (ret.isOk()) ? error : kTransactionError;
 }
 
+Error Mapper::lockEncTurbo(buffer_handle_t bufferHandle, uint64_t usage,
+        const IMapper::Rect& accessRegion,
+        int acquireFence, void** outData) const
+{
+    auto buffer = const_cast<native_handle_t*>(bufferHandle);
+
+    // put acquireFence in a hidl_handle
+    hardware::hidl_handle acquireFenceHandle;
+    NATIVE_HANDLE_DECLARE_STORAGE(acquireFenceStorage, 1, 0);
+    if (acquireFence >= 0) {
+        auto h = native_handle_init(acquireFenceStorage, 1, 0);
+        h->data[0] = acquireFence;
+        acquireFenceHandle = h;
+    }
+
+    Error error;
+    auto ret = mMapper->lockEncTurbo(buffer, usage, accessRegion, acquireFenceHandle,
+            [&](const auto& tmpError, const auto& tmpData)
+            {
+                error = tmpError;
+                if (error != Error::NONE) {
+                    return;
+                }
+
+                *outData = tmpData;
+            });
+
+    // we own acquireFence even on errors
+    if (acquireFence >= 0) {
+        close(acquireFence);
+    }
+
+    return (ret.isOk()) ? error : kTransactionError;
+}
+
 Error Mapper::lock(buffer_handle_t bufferHandle, uint64_t usage,
         const IMapper::Rect& accessRegion,
         int acquireFence, YCbCrLayout* outLayout) const
diff -Nurp a/include/ui/GraphicBuffer.h b/include/ui/GraphicBuffer.h
--- a/include/ui/GraphicBuffer.h	2021-04-21 09:52:36.596403349 +0800
+++ b/include/ui/GraphicBuffer.h	2021-04-21 20:26:51.318293497 +0800
@@ -178,6 +178,8 @@ public:
             int fenceFd);
     status_t lockAsyncYCbCr(uint32_t inUsage, const Rect& rect,
             android_ycbcr *ycbcr, int fenceFd);
+    status_t lockAsyncEncTurbo(uint32_t inUsage, const Rect& rect,
+        void** vaddr, int fenceFd);
     status_t unlockAsync(int *fenceFd);
 
     ANativeWindowBuffer* getNativeBuffer() const;
diff -Nurp a/libs/ui/GraphicBuffer.cpp b/libs/ui/GraphicBuffer.cpp
--- a/libs/ui/GraphicBuffer.cpp	2021-04-21 09:52:36.608403349 +0800
+++ b/libs/ui/GraphicBuffer.cpp	2021-04-21 20:25:40.470290907 +0800
@@ -321,6 +321,22 @@ status_t GraphicBuffer::lockAsyncYCbCr(u
     return res;
 }
 
+// For EncTurbo
+status_t GraphicBuffer::lockAsyncEncTurbo(uint32_t inUsage, const Rect& rect,
+        void** vaddr, int fenceFd)
+{
+    if (rect.left < 0 || rect.right  > width ||
+        rect.top  < 0 || rect.bottom > height) {
+        ALOGE("locking pixels (%d,%d,%d,%d) outside of buffer (w=%d, h=%d)",
+                rect.left, rect.top, rect.right, rect.bottom,
+                width, height);
+        return BAD_VALUE;
+    }
+    status_t res = getBufferMapper().lockAsyncEncTurbo(handle, inUsage, inUsage, rect, vaddr,
+            fenceFd);
+    return res;
+}
+
 status_t GraphicBuffer::unlockAsync(int *fenceFd)
 {
     status_t res = getBufferMapper().unlockAsync(handle, fenceFd);
diff -Nurp a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
--- a/libs/ui/GraphicBufferMapper.cpp	2021-04-21 09:52:36.620403350 +0800
+++ b/libs/ui/GraphicBufferMapper.cpp	2021-04-21 20:25:40.470290907 +0800
@@ -155,6 +155,23 @@ status_t GraphicBufferMapper::lockAsync(
     return static_cast<status_t>(error);
 }
 
+status_t GraphicBufferMapper::lockAsyncEncTurbo(buffer_handle_t handle,
+        uint64_t producerUsage, uint64_t consumerUsage, const Rect& bounds,
+        void** vaddr, int fenceFd)
+{
+    ATRACE_CALL();
+
+    const uint64_t usage = static_cast<uint64_t>(
+            android_convertGralloc1To0Usage(producerUsage, consumerUsage));
+    Gralloc2::Error error = mMapper->lockEncTurbo(handle, usage,
+            asGralloc2Rect(bounds), fenceFd, vaddr);
+
+    ALOGW_IF(error != Gralloc2::Error::NONE, "lock(%p, ...) failed: %d",
+            handle, error);
+
+    return static_cast<status_t>(error);
+}
+
 status_t GraphicBufferMapper::lockAsyncYCbCr(buffer_handle_t handle,
         uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr, int fenceFd)
 {
diff -Nurp a/libs/ui/include/ui/Gralloc2.h b/libs/ui/include/ui/Gralloc2.h
--- a/libs/ui/include/ui/Gralloc2.h	2021-04-21 09:52:36.600403349 +0800
+++ b/libs/ui/include/ui/Gralloc2.h	2021-04-21 20:17:07.702272166 +0800
@@ -76,6 +76,10 @@ public:
             const IMapper::Rect& accessRegion,
             int acquireFence, YCbCrLayout* outLayout) const;
 
+    Error lockEncTurbo(buffer_handle_t bufferHandle, uint64_t usage,
+           const IMapper::Rect& accessRegion,
+           int acquireFence, void** outData) const;
+           
     // unlock returns a fence sync object (or -1) and the fence sync object is
     // owned by the caller
     int unlock(buffer_handle_t bufferHandle) const;
diff -Nurp a/libs/ui/include/ui/GraphicBufferMapper.h b/libs/ui/include/ui/GraphicBufferMapper.h
--- a/libs/ui/include/ui/GraphicBufferMapper.h	2021-04-21 09:52:36.600403349 +0800
+++ b/libs/ui/include/ui/GraphicBufferMapper.h	2021-04-21 20:27:37.138295172 +0800
@@ -78,6 +78,10 @@ public:
             uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr,
             int fenceFd);
 
+    status_t lockAsyncEncTurbo(buffer_handle_t handle,
+            uint64_t producerUsage, uint64_t consumerUsage, const Rect& bounds,
+            void** vaddr, int fenceFd);
+
     status_t unlockAsync(buffer_handle_t handle, int *fenceFd);
 
     const Gralloc2::Mapper& getGrallocMapper() const
diff -Nurp a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
--- a/libs/gui/BufferQueueProducer.cpp	2021-11-03 09:45:27.578270658 +0000
+++ b/libs/gui/BufferQueueProducer.cpp	2021-11-03 09:43:33.398275681 +0000
@@ -38,6 +38,7 @@
 
 #include <utils/Log.h>
 #include <utils/Trace.h>
+#include <cutils/properties.h>
 
 #include <system/window.h>
 
@@ -383,7 +384,11 @@ status_t BufferQueueProducer::dequeueBuf
         Mutex::Autolock lock(mCore->mMutex);
         mCore->waitWhileAllocatingLocked();
 
-        if (format == 0) {
+        char propBuf[PROPERTY_VALUE_MAX];
+        property_get("vmi.videostream.engine", propBuf, NULL);
+
+        if (format == 0 ||
+            (mConsumerName == "capture" && std::string(propBuf) == "true")) {
             format = mCore->mDefaultBufferFormat;
         }
 
